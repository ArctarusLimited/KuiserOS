diff --git a/src/libexpr/flake/flake.cc b/src/libexpr/flake/flake.cc
index 3e866e1f9..21edc6972 100644
--- a/src/libexpr/flake/flake.cc
+++ b/src/libexpr/flake/flake.cc
@@ -306,20 +306,24 @@ LockedFlake lockFlake(
 
     std::vector<FlakeRef> parents;
 
+    // relative = are we currently inside a subordinate lockfile?
+    // relativeDepth = how many levels deep are we inside said lockfile?
     std::function<void(
         const FlakeInputs & flakeInputs,
         std::shared_ptr<Node> node,
         const InputPath & inputPathPrefix,
-        std::shared_ptr<const Node> oldNode)>
+        std::shared_ptr<const Node> oldNode,
+        const bool relative, const int relativeDepth)>
         computeLocks;
 
     computeLocks = [&](
         const FlakeInputs & flakeInputs,
         std::shared_ptr<Node> node,
         const InputPath & inputPathPrefix,
-        std::shared_ptr<const Node> oldNode)
+        std::shared_ptr<const Node> oldNode,
+        const bool relative, const int relativeDepth)
     {
-        debug("computing lock file node '%s'", printInputPath(inputPathPrefix));
+        debug("computing lock file node '%s' (depth %i)", printInputPath(inputPathPrefix), relativeDepth);
 
         /* Get the overrides (i.e. attributes of the form
            'inputs.nixops.inputs.nixpkgs.url = ...'). */
@@ -353,11 +357,20 @@ LockedFlake lockFlake(
                path we haven't processed yet. */
             if (input.follows) {
                 InputPath target;
-                if (hasOverride || input.absolute)
+                if (hasOverride || input.absolute) {
                     /* 'follows' from an override is relative to the
-                       root of the graph. */
-                    target = *input.follows;
-                else {
+                       root of the graph, but we need to fix up the path for subordinate lockfiles. */
+                    if (relative) {
+                        target = inputPathPrefix;
+
+                        // special case for the root of the subordinate - we need to pop once
+                        if (!relativeDepth) target.pop_back();
+                        for (int i = 0; i < relativeDepth; i++) target.pop_back();
+                        for (auto & i : *input.follows) target.push_back(i);
+                    } else {
+                        target = *input.follows;
+                    }
+                } else {
                     /* Otherwise, it's relative to the current flake. */
                     target = inputPathPrefix;
                     for (auto & i : *input.follows) target.push_back(i);
@@ -407,7 +420,7 @@ LockedFlake lockFlake(
                 if (hasChildUpdate) {
                     auto inputFlake = getFlake(
                         state, oldLock->lockedRef, false, flakeCache);
-                    computeLocks(inputFlake.inputs, childNode, inputPath, oldLock);
+                    computeLocks(inputFlake.inputs, childNode, inputPath, oldLock, relative, relativeDepth + 1);
                 } else {
                     /* No need to fetch this flake, we can be
                        lazy. However there may be new overrides on the
@@ -429,7 +442,7 @@ LockedFlake lockFlake(
                         }
                     }
 
-                    computeLocks(fakeInputs, childNode, inputPath, oldLock);
+                    computeLocks(fakeInputs, childNode, inputPath, oldLock, relative, relativeDepth + 1);
                 }
 
             } else {
@@ -471,7 +484,8 @@ LockedFlake lockFlake(
                         oldLock
                         ? std::dynamic_pointer_cast<const Node>(oldLock)
                         : LockFile::read(
-                            inputFlake.sourceInfo->actualPath + "/" + inputFlake.lockedRef.subdir + "/flake.lock").root);
+                            inputFlake.sourceInfo->actualPath + "/" + inputFlake.lockedRef.subdir + "/flake.lock").root,
+                        !oldLock, 0);
                 }
 
                 else {
@@ -486,7 +500,7 @@ LockedFlake lockFlake(
 
     computeLocks(
         flake.inputs, newLockFile.root, {},
-        lockFlags.recreateLockFile ? nullptr : oldLockFile.root);
+        lockFlags.recreateLockFile ? nullptr : oldLockFile.root, false, 0);
 
     for (auto & i : lockFlags.inputOverrides)
         if (!overridesUsed.count(i.first))
